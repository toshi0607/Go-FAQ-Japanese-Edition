# GoogleでのGo: ソフトウェアエンジニアリングのための言語設計

[Go at Google: Language Design in the Service of Software Engineering](https://go.dev/talks/2012/splash.article)の日本語版です。

## 1. 概要

（本記事は、2012年10月25日にアリゾナ州ツーソンで開催されたSPLASH 2012カンファレンスでRob Pikeが行った基調講演を修正したものです。）

プログラミング言語Goは、2007年末にGoogleでソフトウェアインフラストラクチャを開発する際に直面したいくつかの問題に対する答えとして考え出されたものです。今日のコンピューティングの状況は、主にC++、Java、Pythonといった使用されている言語が作られた環境とはほとんど無関係になっています。マルチコアプロセッサ、ネットワークシステム、大規模な計算クラスター、Webプログラミングモデルによってもたらされた問題は、正面から取り組むのではなく、回避する方向に進んでいました。さらに、規模も変わりました。今日のサーバープログラムは、数千万行のコードから成り、数百人、数千人のプログラマによって作業され、文字通り毎日更新されています。さらに悪いことに、大規模なコンパイルクラスタであっても、ビルド時間は数分、数時間にまで伸びています。

Goはこのような環境での作業をより生産的にするために設計、開発されました。組み込みの並行処理やガベージコレクションといったよく知られた点以外にも、Goの設計では、厳密な依存関係の管理、システムの成長に合わせたソフトウェアアーキテクチャの適応性、コンポーネント間の境界を越えた堅牢性などが考慮されています。

この記事では、これらの課題を解決しながらも、軽量で快適な効率的なコンパイル型プログラミング言語を構築した方法を紹介します。例として、Googleで実際に直面した問題を取り上げて解説します。

## 2. 導入

Goは、Googleで開発されたコンパイル可能な並列処理、ガベージコレクション、静的型付け言語です。オープンソースのプロジェクトで、Googleが公開リポジトリをインポートしているのであって、その逆ではありません。

Goは効率的で、スケーラブルで、生産的です。Goで働くことを楽しいと感じるプログラマもいれば、想像力に欠け、退屈だとさえ感じるプログラマもいます。この記事では、それらが矛盾した立場でない理由を説明します。Goは、Googleのソフトウェア開発で直面した問題を解決するために設計されました。その結果、画期的な研究言語ではありませんが、それでも大規模ソフトウェアプロジェクトをエンジニアリングするための優れたツールである言語が生まれました。

## 3. GoogleでのGo

Goは、GoogleがGoogleの問題を解決するために設計したプログラミング言語であり、Googleは大きな問題を抱えています。

ハードウェアもソフトウェアも巨大です。何百万行ものソフトウェアがあり、サーバーのほとんどはC++で、その他の部分にはJavaやPythonが多く使われています。数千人のエンジニアが、すべてのソフトウェアを構成する1つのツリーの「ヘッド」でコードに取り組んでいるため、日々、ツリーの全レベルに大きな変更が加えられているのです。大規模な[カスタム設計の分散ビルドシステム](http://google-engtools.blogspot.com/2011/06/build-in-cloud-accessing-source-code.html)によって、この規模の開発は実現可能ですが、それでもまだ大きいです。

もちろん、これらのソフトウェアは何十億台ものマシンで動作しており、それらはネットワークでつながった独立した適度な数の計算クラスタとして扱われています。

つまり、Googleの開発は大きく、遅く、不器用であることが多いのです。しかし、それは有効ではあります。

Goプロジェクトの目標は、Googleのソフトウェア開発の遅さと不器用さを解消し、そのプロセスをより生産的でスケーラブルなものにすることでした。この言語は、大規模なソフトウェアシステムを書き、読み、デバッグし、保守する人々によって、またその人々のために設計されました。

したがって、Goの目的はプログラミング言語設計の研究ではなく、設計者とその同僚の作業環境を改善することにあるのです。Goはプログラミング言語の研究というより、ソフトウェアエンジニアリングのためのものです。言い換えれば、ソフトウェアエンジニアリングのための言語設計なのです。

しかし、言語がどのようにソフトウェアエンジニアリングに役立つのでしょうか。この記事の続きは、その質問への答えです。

## 4. ペインポイント

Goが公開されたとき、モダンな言語の必須条件とされる特定の機能や方法論が欠落していると主張する人がいました。このような機能がないのに、どうしてGoに価値があるのでしょうか。それに対する私たちの答えは、Goが持つ特性は、大規模なソフトウェア開発を困難にする問題に対処するものである、ということです。その問題とは次のようなものです。

- 遅いビルド
- 無秩序な依存関係
- 各プログラマが異なる言語のサブセットを使用している
- プログラムの理解度が低い（コードが読みにくい、ドキュメント化が不十分、等々）
- 労力の重複
- 更新のコスト
- バージョンのずれ
- 自動化ツールの作成が困難
- 異なる言語でのビルド

言語の個々の機能では、これらの問題に対処できません。ソフトウェアエンジニアリングの大局的な視点が必要であり、Goの設計では、これらの問題に対する解決策に焦点を当てるように努めました。

シンプルで自己完結した例として、プログラム構造の表現について考えてみましょう。Goの中括弧を使ったC言語のようなブロック構造に異議を唱え、PythonやHaskellのような空白を使ったインデントを好む人もいます。しかし、私たちは、たとえばSWIGの呼び出しによって他の言語に埋め込まれたPythonのスニペットが、周囲のコードのインデントを変更することによって微妙にそして人知れず壊れてしまうような、言語横断ビルドによって引き起こされるビルドとテストの失敗をたくさん追跡してきました。したがって、私たちの立場は、インデント用のスペースは小さなプログラムには良いですが、うまくスケールしませんし、コードベースが大きく不均質であればあるほど、より多くの問題を引き起こす可能性があるということです。安全性と信頼性のためには利便性を犠牲にしたほうがよいので、Goには中括弧で囲まれたブロックがあります。

## 5. CとC++の依存関係

パッケージの依存性を扱うことで、スケーリングやその他の問題をより実質的に説明することができます。まず、CとC++でどのように機能するかの復習から議論を始めます。

1989年に初めて標準化されたANSI Cでは、標準のヘッダーファイルに`#ifndef`の「ガード」という考えを推進しました。これは、各ヘッダファイルを条件付きコンパイル句で括り、そのファイルがエラーなしに複数回含まれるようにするというもので、現在では広く普及しています。たとえば、Unixのヘッダーファイル`<sys/stat.h>`は、概略的には次のようなものです。

```c
/* Large copyright and licensing notice */
#ifndef _SYS_STAT_H_
#define _SYS_STAT_H_
/* Types and other definitions */
#endif
```

これは、Cプリプロセッサがファイルを読み込んでも、2回目以降の読み込みではその内容を無視することを意図しています。シンボル`_SYS_STAT_H_`は、ファイルを最初に読み込んだときに定義され、その後の呼び出しを「ガード」しています。

このデザインにはいくつかの良い特性があり、最も重要なのは、各ヘッダーファイルが、他のヘッダーファイルもインクルードするとしても、すべての依存関係を安全に`#include`できることです。このルールに従えば、たとえば`#include`句をアルファベット順に並べるような、整然としたコード記述が可能になります。

しかし、それはあまりスケールしません。

1984年、Unixの`ps`コマンドのソースである`ps.c`をコンパイルすると、すべての前処理が終わるまでに37回<sys/stat.h>を#includeすることが確認されました。その間に36回内容を破棄しているにもかかわらず、ほとんどのC実装では、ファイルを開き、読み、37回すべてスキャンしてしまうのです。実際、巧妙でなければ、Cプリプロセッサの潜在的に複雑なマクロのセマンティクスによってこのような動作が要求されるのです。

ソフトウェアへの影響としては、C言語のプログラムに`#include`句が徐々に蓄積されていくことが挙げられます。インクルードを追加してもプログラムは壊れないですし、いつインクルードが不要になるかを知るのは非常に難しいです。ある`#include`を削除して再度プログラムをコンパイルしても、別の`#include`がそれ自体を含んでいて、いずれそれを取り込むかもしれないので、それをテストするのに十分でもありません。

技術的に言えば、そうである必要はありません。`#ifndef`ガードの使用による長期的な問題を認識していたPlan 9ライブラリの設計者は、異なる非ANSI標準のアプローチを取りました。Plan 9では、ヘッダーファイルにこれ以上`#include`句を入れることを禁止し、すべての`#include`をトップレベルのCファイルに入れることを義務付けました。もちろん、プログラマは必要な依存関係を一度だけ正しい順序でリストアップしなければならないので、ある程度の規律は必要ですが、ドキュメント化することで助けられ、実際には非常にうまくいきました。その結果、C言語のソースファイルにどれだけ多くの依存関係があったとしても、そのファイルをコンパイルする際には、それぞれの`#include`ファイルが一度だけ読まれることになりました。もちろん、`#include`が必要かどうかは、それを削除することで簡単に確認することができました。

Plan 9のアプローチで最も重要な結果は、コンパイルの高速化です。`#ifndef`ガードを持つライブラリを使ってプログラムをコンパイルする場合と比べて、コンパイルに必要なI/Oの量が劇的に少なくなる可能性があります。

しかし、Plan9以外では、「ガード付き」アプローチはCとC++で受け入れられているプラクティスです。実際、C++は同じアプローチをより細かい粒度で使用することにより、問題を悪化させています。慣習上、C++プログラムは通常1クラスにつき1つのヘッダーファイル、あるいは関連するクラスの小さなセット、たとえば`<stdio.h>`よりもはるかに小さなグループ分けで構成されています。したがって、依存関係ツリーは、ライブラリ依存ではなく、完全な型階層を反映したより複雑なものとなっています。さらに、C++のヘッダーファイルには、Cのヘッダーファイルによくある単純な定数や関数シグネチャだけでなく、実際のコード、メソッド、テンプレートの宣言が含まれているのが一般的です。このように、C++はコンパイラに多くのものを押し付けるだけでなく、押し付けられたものはコンパイルしにくく、コンパイラを起動するたびにこの情報を再処理しなければなりません。大きなC++バイナリをビルドするとき、コンパイラはヘッダーファイル`<string>`を処理することによって、文字列をどのように表現するかを何千回も教えられるかもしれません。(ちなみに1984年頃、Tom Cargill氏は依存関係の管理にCプリプロセッサを使うことはC++にとって長期的な負債となり、対処すべきであると指摘していました)。

Googleの1つのC++バイナリの構築は、何百もの個別のヘッダーファイルを何万回も開いて読み取る可能性があります。2007年、Googleのビルドエンジニアは、Googleの主要なバイナリのコンパイルを測定しました。そのファイルには約2000のファイルが含まれており、単純に連結すると合計4.2メガバイトになります。`#include`が展開されるまでに、8ギガバイト以上がコンパイラの入力に送られ、C++のソース1バイトに対して2000バイトが吹き飛ぶことになりました。

別の事例として、2003年にGoogleのビルドシステムが単一のMakefileからディレクトリ単位のデザインに移行されてより良く管理され、より明確な依存関係を持つようになりました。典型的なバイナリは、より正確な依存関係が記録されるだけでファイルサイズが約40%縮小されました。それでも、C++（あるいはC言語）の特性上、依存関係を自動的に検証することは現実的ではなく、今日でも大規模なGoogle C++バイナリの依存性要件について正確な理解は得られていません。

これらの制御不能な依存関係と大規模化の結果、Googleサーバーのバイナリを一台のコンピュータで構築することは非現実的であるため、大規模な分散コンパイルシステムが作成されました。このシステムは、多くのマシン、多くのキャッシュ、そして多くの複雑さ（ビルドシステムはそれ自体が大きなプログラムです）を伴います。Googleでのビルドは、依然として煩雑であるとしても実用的なものです。

分散ビルドシステムを使っても、大規模なGoogleのビルドには何分もかかることがあります。2007年のバイナリは、先駆的な分散型ビルドシステムを使用して45分かかりました。現在の同プログラムのバージョンでは27分かかりますが、もちろんその間にプログラムとその依存関係は拡大してきました。ビルドシステムを拡張するために必要なエンジニアリングの努力は、構築するソフトウェアの成長にかろうじて先行することができる程度です。

## 6. Goへ

ビルドが遅いと、考える時間があります。Goの起源神話によると、Goが考案されたのは、この45分間のビルドのうちの1回だったと言われています。ウェブサーバーのような大規模なGoogleプログラムを書くのに適した新しい言語を、Googleプログラマの生活の質を向上させるソフトウェアエンジニアリング的配慮をもって設計することは、試みる価値があると信じられていました。

ここまでの議論は依存関係に焦点を当てたものでしたが、他にも注意を払うべき問題が多く存在します。この文脈で成功するためには、どのような言語であっても、主に次のようなことを考慮する必要があります。

- 大規模なプログラム、多数の依存関係、大規模なプログラマチームに対してスケールする必要があります。
- おおよそC言語風の親しみやすいものでなければなりません。Googleで働くプログラマはキャリアが浅く、手続き型言語、特にC言語系に最も慣れています。新しい言語でプログラマを早く生産的にする必要があるため、その言語はあまり過激であってはならないのです。
- モダンなものでなければなりません。C、C++、そしてJavaもある程度は、マルチコアマシン、ネットワーキング、ウェブアプリケーション開発などの出現以前に設計された、かなり古いものです。ビルトインの並行処理など、より新しいアプローチで対応した方が良い現代社会の特徴があります。

このような背景から、Goの設計をソフトウェアエンジニアリングの観点から見てみましょう。
