# GoogleでのGo: ソフトウェアエンジニアリングのための言語設計

[Go at Google: Language Design in the Service of Software Engineering](https://go.dev/talks/2012/splash.article)の日本語版です。

## 1. 概要

（本記事は、2012年10月25日にアリゾナ州ツーソンで開催されたSPLASH 2012カンファレンスでRob Pikeが行った基調講演を修正したものです。）

プログラミング言語Goは、2007年末にGoogleでソフトウェアインフラストラクチャを開発する際に直面したいくつかの問題に対する答えとして考え出されたものです。今日のコンピューティングの状況は、主にC++、Java、Pythonといった使用されている言語が作られた環境とはほとんど無関係になっています。マルチコアプロセッサ、ネットワークシステム、大規模な計算クラスター、Webプログラミングモデルによってもたらされた問題は、正面から取り組むのではなく、回避する方向に進んでいました。さらに、規模も変わりました。今日のサーバープログラムは、数千万行のコードから成り、数百人、数千人のプログラマによって作業され、文字通り毎日更新されています。さらに悪いことに、大規模なコンパイルクラスタであっても、ビルド時間は数分、数時間にまで伸びています。

Goはこのような環境での作業をより生産的にするために設計、開発されました。組み込みの並行処理やガベージコレクションといったよく知られた点以外にも、Goの設計では、厳密な依存関係の管理、システムの成長に合わせたソフトウェアアーキテクチャの適応性、コンポーネント間の境界を越えた堅牢性などが考慮されています。

この記事では、これらの課題を解決しながらも、軽量で快適な効率的なコンパイル型プログラミング言語を構築した方法を紹介します。例として、Googleで実際に直面した問題を取り上げて解説します。

## 2. 導入

Goは、Googleで開発されたコンパイル可能な並列処理、ガベージコレクション、静的型付け言語です。オープンソースのプロジェクトで、Googleが公開リポジトリをインポートしているのであって、その逆ではありません。

Goは効率的で、スケーラブルで、生産的です。Goで働くことを楽しいと感じるプログラマーもいれば、想像力に欠け、退屈だとさえ感じるプログラマもいます。この記事では、それらが矛盾した立場でない理由を説明します。Goは、Googleのソフトウェア開発で直面した問題を解決するために設計されました。その結果、画期的な研究言語ではありませんが、それでも大規模ソフトウェアプロジェクトをエンジニアリングするための優れたツールである言語が生まれました。

## 3. GoogleでのGo

Goは、GoogleがGoogleの問題を解決するために設計したプログラミング言語であり、Googleは大きな問題を抱えています。

ハードウェアもソフトウェアも巨大です。何百万行ものソフトウェアがあり、サーバーのほとんどはC++で、その他の部分にはJavaやPythonが多く使われています。数千人のエンジニアが、すべてのソフトウェアを構成する1つのツリーの「ヘッド」でコードに取り組んでいるため、日々、ツリーの全レベルに大きな変更が加えられているのです。大規模な[カスタム設計の分散ビルドシステム](http://google-engtools.blogspot.com/2011/06/build-in-cloud-accessing-source-code.html)によって、この規模の開発は実現可能ですが、それでもまだ大きいです。

もちろん、これらのソフトウェアは何十億台ものマシンで動作しており、それらはネットワークでつながった独立した適度な数の計算クラスタとして扱われています。

つまり、Googleの開発は大きく、遅く、不器用であることが多いのです。しかし、それは有効ではあります。

Goプロジェクトの目標は、Googleのソフトウェア開発の遅さと不器用さを解消し、そのプロセスをより生産的でスケーラブルなものにすることでした。この言語は、大規模なソフトウェアシステムを書き、読み、デバッグし、保守する人々によって、またその人々のために設計されました。

したがって、Goの目的はプログラミング言語設計の研究ではなく、設計者とその同僚の作業環境を改善することにあるのです。Goはプログラミング言語の研究というより、ソフトウェアエンジニアリングのためのものです。言い換えれば、ソフトウェアエンジニアリングのための言語設計なのです。

しかし、言語がどのようにソフトウェアエンジニアリングに役立つのでしょうか。この記事の続きは、その質問への答えです。
